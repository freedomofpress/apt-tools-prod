#!/usr/bin/env python3
"""
Script for managing updates to a 'reprepro' apt repository.
Expects a certain dir structure, will loop over distributions
specified in subdirectories, then publish all deb packages
found in each.
"""
import os
import subprocess


REPO_ROOT = os.path.abspath(os.path.join(__file__, os.pardir, os.pardir))
REPROPRO_DIR_DEFAULT = os.path.join(REPO_ROOT, "repo")
REPREPRO_DIR = os.environ.get("REPREPRO_BASE_DIR", REPROPRO_DIR_DEFAULT)
REPREPRO_PUBLIC_DIR = os.path.join(REPREPRO_DIR, "public")

REPO_DIRS = [
    "dangerzone",
]


def publish_packages(repo_subdir):
    """
    Lists all deb packages, first by parent repo, then by distribution,
    and adds them via reprepro, updating metadata in the process.
    """
    repo_path = os.path.join(REPO_ROOT, repo_subdir)
    assert os.path.exists(repo_path)
    repo_distros = os.listdir(repo_path)
    # Add deb packages for each distro, by codename
    for distro in repo_distros:
        distro_path = os.path.join(repo_path, distro)
        if '-' in distro:
            distro, component = distro.split('-', 1)
        else:
            component = 'main'
        debs = os.listdir(distro_path)
        # Build fullpaths to deb packages
        debs = [os.path.join(distro_path, x) for x in debs if x.endswith(".deb")]  # noqa
        # Sort the debs so that older versions are still included.
        # Not perfect, since it's alpha sort, rather than numeric/semver.
        debs.sort()
        cmd = [
            "reprepro",
            "-C",
            component,
            "--basedir",
            REPREPRO_DIR,
            "--outdir",
            REPREPRO_PUBLIC_DIR,
            "includedeb",
            distro,
        ]
        if len(debs) < 1:
            continue

        cmd += debs
        subprocess.check_call(cmd)


def validate_repo():
    """
    Confirm that repository is well structured.
    """
    reprepro_validations = [
        "check",
        "checkpool",
    ]
    for action in reprepro_validations:
        cmd = [
            "reprepro",
            "--basedir",
            REPREPRO_DIR,
            "--outdir",
            REPREPRO_PUBLIC_DIR,
            action
        ]
        subprocess.check_call(cmd)


def get_release_files():
    """
    Find all Release files, to facilitate generating a detached
    signature file via airgapped signing process.
    """
    dists_dir = os.path.join(REPREPRO_PUBLIC_DIR, "dists")
    find_cmd = ["find", dists_dir, "-iname", "Release"]
    find_results = subprocess.check_output(find_cmd).decode("utf-8").rstrip()
    find_results = find_results.split("\n")
    # Results will include e.g.:
    #
    #   ./repo/public/dists/focal/main/binary-amd64/Release
    #   ./repo/public/dists/focal/Release
    #
    # Only the latter should be signed.
    find_results = [x for x in find_results if "binary" not in x]
    return find_results


def signing_instructions():
    release_files = get_release_files()

    print("Release files have been generated:\n")
    for f in release_files:
        print("\t * "+f)
    print("\nAdd a detached signature file (.gpg) for each,")
    print("and commit those changes to finalize the release.")


if __name__ == "__main__":
    assert os.path.exists(REPREPRO_DIR)
    validate_repo()
    for repo in REPO_DIRS:
        publish_packages(repo)
    validate_repo()
    signing_instructions()
